// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ChannelBlitter

Texture2D<uint4> _BlitTexture;
RWTexture2D<uint4> _BlitDestination;

static const uint R = 0;
static const uint G = 1;
static const uint B = 2;
static const uint A = 3;
static const uint None = 4;

/// @brief Parameters controlling the channel blitter.
/// @param _R Index of source channel to copy to red output (or None).
/// @param _G Index of source channel to copy to green output (or None).
/// @param _B Index of source channel to copy to blue output (or None).
/// @param _A Index of source channel to copy to alpha output (or None).
/// @param _BlitParams.xy Pixel offset for source sampling.
/// @param _BlitParams.zw Width and height of the region to blit.
cbuffer _ChannelBlitterParams
{
    uint _R;
    uint _G;
    uint _B;
    uint _A;
    
    float4 _BlitParams;
};

/// @brief Copies selected channels from a source texture to a destination texture.
/// @details Uses the offsets in _BlitParams.xy as the starting pixel coordinate and
/// clips to the region defined by _BlitParams.zw. Only channels with index less than None are copied.
/// @param id Dispatch thread ID corresponding to the destination pixel.
[numthreads(8,8,1)]
void ChannelBlitter (uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint) _BlitParams.z && id.y < (uint) _BlitParams.w)
    {
        uint2 coords = uint2(_BlitParams.x, _BlitParams.y) + uint2(_BlitParams.z, _BlitParams.w);
        uint4 sample = _BlitTexture[coords];
        
        uint4 dest = (uint4) 0;
        if (_R < None) dest.r = sample[_R];
        if (_G < None) dest.g = sample[_G];
        if (_B < None) dest.b = sample[_B];
        if (_A < None) dest.a = sample[_A];
        
        _BlitDestination[id.xy] = dest;
    }
}

